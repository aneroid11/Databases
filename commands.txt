Создать базу данных:
create database task3;
use task3;

Создание таблиц:

Пользователи (Users):
create table Users (
    idUsers int not null auto_increment,
    email varchar(255) not null,
    password_hash varchar(255) not null,
    role enum('artist', 'admin', 'moderator') not null,

    primary key(idUsers)
);

Артисты (Artists):
create table Artists (
    idArtists int not null auto_increment,
    nickname varchar(100) not null,
    date_of_birth date,
    gender enum('male', 'female', 'nonbinary') not null,
    country varchar(45),
    premium_subscription_id int,
    card_details_id int,

    primary key(idArtists),
    foreign key(premium_subscription_id) references PremiumSubscriptions(idPremiumSubscriptions),
    foreign key(card_details_id) references CardDetails(idCardDetails)
);

Данные банковских карт (CardDetails):
create table CardDetails (
    idCardDetails int not null auto_increment,
    first_name varchar(60) not null,
    last_name varchar(80) not null,
    card_number varchar(16) not null,
    expiration date not null,
    
    primary key(idCardDetails)
);

Премиум-подписки:
create table PremiumSubscriptions (
    idPremiumSubscriptions int not null auto_increment,
    start_datetime datetime not null,
    end_datetime datetime not null,
    active boolean not null,
    id_tariff int not null,
    
    primary key(idPremiumSubscriptions),
    foreign key(id_tariff) references Tariffs(idTariffs)
);

Тарифы:
create table Tariffs (
    idTariffs int not null auto_increment,
    monthly_payment_dollars float not null,

    primary key(idTariffs)
);

Платежи:
create table Payments (
    idPayments int not null auto_increment,
    subscription_id int not null,
    timestamp datetime not null,
    status enum('pending', 'failed', 'successful') not null,
    sum float not null,
    transaction_id varchar(100) not null

    primary key(idPayments)
);

Жалобы:
create table Reports (
    idReports int not null auto_increment,
    title varchar(50) not null,
    contents varchar(200),
    author_id int not null,
    report_type enum('Tracks', 'Artists') not null,
    object_id int not null

    primary key(idReports),
    foreign key(author_id) references Artists(idArtists)
);

Лайки:
create table Likes (
    idLikes int not null,
    artist_id int,
    track_id int not null,
    
    primary key(idLikes),
    foreign key(artist_id) references Artists(idArtists),
    foreign key(track_id) references Tracks(idTracks)
);

Теги:
create table Tags (
    idTags int not null,
    name varchar(45) not null,

    primary key(idTags)
);

Треки:
create table Tracks (
    idTracks int not null,
    timestamp datetime not null,
    title varchar(100) not null,
    length_seconds int not null,
    artist_id int not null,

    primary key(idTracks),
    foreign key(artist_id) references Artists(idArtists)
);

Комментарии:
create table Comments (
    idComments int not null,
    timestamp datetime not null,
    contents varchar(500) not null,
    artist_id int,
    track_id int not null,

    primary key(idComments),
    foreign key(artist_id) references Artists(idArtists),
    foreign key(
);

Плейлисты:
create table Playlists (
    idPlaylists int,
    title varchar(100),
    artist_id int
);

Альбомы:
create table Albums (
    idAlbums int,
    release_date date
);

Журнал действий пользователей:
create table Actions (
    idActions int,
    timestamp datetime,
    user_id int,
    object_type enum('Users', 'Artists', 'CardDetails', 'Likes', 'Comments', 'Reports', 'PremiumSubscriptions', 'Payments', 'Tags', 'Tracks', 'Playlists', 'Albums'),
    object_id int,
    action_type enum('create', 'read', 'update', 'delete')
);




индексы - те самые индексы, которые чисто для оптимизации. Скорее всего, их надо проставить уже после того, как будет создан пул запросов, чтобы оптимизировалось то, что надо.
констрейнты - это и есть те проверки, check, not null, unique и так далее:
https://www.w3schools.com/sql/sql_constraints.asp

прочие ограничения - мб домены.

индексы
есть таблица, например, таблица первичных ключей и соответствующих им "ссылок" (хз, как они работают) на объекты с такими первичными ключами

если происходит select * from table where pk=2, то 
без индекса: проходим по всем строкам таблицы, сравниваем первичный ключ с 2 и если совпадает, то это то, что нужно
с индексом: смотрим в таблице индексов, переходим по ссылке и находим нужный объект.
